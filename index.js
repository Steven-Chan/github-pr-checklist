// Generated by CoffeeScript 1.9.2
(function() {
  var Client, Sequelize, SequelizeMigration, app_config, clients, createHandler, create_table, fs, github, githubAPI, github_authorize, github_request_token, handler, http, https, listen_pullrequest, pg, port, querystring, sequelize, server, url, uuid;

  http = require('http');

  https = require('https');

  fs = require('fs');

  url = require('url');

  querystring = require('querystring');

  uuid = require('node-uuid');

  port = process.env.PORT || 8080;

  app_config = {
    name: 'github-pr-checklist',
    client_id: '74ca93a65bffa081a74d',
    client_secret: '5e56b44128e1b02c382291baf36cb605a0fe6a02',
    redirect_uri: 'https://github-pr-checklist.herokuapp.com/oauth-callback'
  };

  createHandler = require('./github-webhook-handler.js');

  handler = createHandler({
    path: '/github-web-hook',
    secret: 'oursky'
  });

  handler.on('error', function(err) {
    return console.error('Error: ', err.message);
  });

  handler.on('push', function(event) {
    return console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref);
  });

  handler.on('pull_request', function(event) {
    console.log('Received a pull request on %s', event.payload.repository.full_name);
    if (event.payload.action === 'opened') {
      return Client.findOne({
        where: {
          repo: event.payload.repository.full_name
        }
      }).then(function(matched_client) {
        var options, token_req;
        options = {
          hostname: 'api.github.com',
          path: '/repos/' + matched_client.repo + '/pulls/' + event.payload.number,
          method: 'PATCH',
          headers: {
            'User-Agent': app_config.name,
            'Authorization': 'token ' + matched_client.access_token
          }
        };
        token_req = https.request(options, function(token_res) {
          var body;
          console.log('Status: ', token_res.statusCode);
          console.log('Headers: ', JSON.stringify(token_res.headers));
          token_res.setEncoding('utf8');
          body = '';
          token_res.on('data', function(chunk) {
            return body += chunk;
          });
          return token_res.on('end', function() {
            return console.log(body);
          });
        });
        token_req.on('error', function(err) {
          return console.log('problem with request: ', e.message);
        });
        token_req.write(JSON.stringify({
          title: event.payload.pull_request.title,
          body: event.payload.pull_request.body + '\n' + matched_client.body,
          state: event.payload.pull_request.state
        }));
        return token_req.end();
      });
    }
  });

  githubAPI = require('github');

  github = new githubAPI({
    version: "3.0.0"
  });

  github_authorize = function(res, client_id, redirect_uri, state) {
    res.writeHead(302, {
      Location: 'https://github.com/login/oauth/authorize?client_id=' + client_id + '&redirect_uri=' + redirect_uri + '&scope=repo&state=' + state
    });
    return res.end();
  };

  github_request_token = function(client_id, client_secret, code, callback) {
    var options, token_req;
    options = {
      hostname: 'github.com',
      path: '/login/oauth/access_token',
      method: 'POST'
    };
    token_req = https.request(options, function(token_res) {
      var body;
      console.log('Status: ', token_res.statusCode);
      console.log('Headers: ', JSON.stringify(token_res.headers));
      token_res.setEncoding('utf8');
      body = '';
      token_res.on('data', function(chunk) {
        return body += chunk;
      });
      return token_res.on('end', function() {
        console.log(body);
        return callback(body);
      });
    });
    token_req.on('error', function(err) {
      return console.log('problem with request: ', e.message);
    });
    token_req.write('client_id=' + client_id + '&client_secret=' + client_secret + '&code=' + code);
    return token_req.end();
  };

  clients = [];

  pg = require('pg');

  Sequelize = require('sequelize');

  SequelizeMigration = require('sequelize/');

  sequelize = function() {
    var _host, _port, _url;
    _url = process.env.HEROKU_POSTGRESQL_CYAN_URL;
    _host = _url.split('@')[1].split(':')[0];
    _port = _url.split('@')[1].split(':')[1].split('/')[0];
    return new Sequelize(_url, {
      dialect: 'postgres',
      protocol: 'postgres',
      port: _port,
      host: _host,
      logging: true,
      dialectOptions: {
        ssl: true
      }
    });
  };

  Client = void 0;

  create_table = function() {
    var _seq;
    _seq = sequelize();
    Client = _seq.define('client', {
      state: Sequelize.STRING,
      repo: Sequelize.STRING,
      body: Sequelize.STRING(1024),
      access_token: Sequelize.STRING
    });
    return _seq.sync();
  };

  create_table();

  listen_pullrequest = {
    get: function(res, params, body) {
      var random_state;
      random_state = uuid.v1();
      return sequelize().sync().then(function() {
        return Client.count({
          where: {
            repo: params.repo
          }
        }).then(function(count) {
          if (count === 0) {
            return Client.create({
              state: random_state,
              repo: params.repo,
              body: params.body || ''
            }).then((function() {
              return github_authorize(res, app_config.client_id, app_config.redirect_uri, random_state);
            }));
          } else {
            return res.end('repo registered');
          }
        });
      });
    },
    "delete": function(res, params, body) {
      return sequelize().sync().then(function() {
        return Client.destroy({
          where: {
            repo: params.repo
          },
          force: true
        }).then(function() {
          return res.end('deleted: ' + params.repo);
        });
      });
    },
    patch: function(res, params, body) {
      console.log('update body to: ', body);
      return sequelize().sync().then(function() {
        return Client.update({
          body: body
        }, {
          where: {
            repo: params.repo
          }
        }).then(function() {
          return res.end('updated: ' + params.repo);
        });
      });
    }
  };

  server = http.createServer(function(req, res) {
    var client, i, len, matched_client, method, parts, pathname, query, req_body;
    parts = url.parse(req.url, true);
    query = parts.query;
    pathname = parts.pathname;
    method = req.method.toLowerCase();
    console.log("visiting (%s) : %s", req.method, req.url);
    if (pathname === '/test-oauth') {
      return github_authorize(res, app_config.client_id, app_config.redirect_uri);
    } else if (pathname === '/oauth-callback') {
      return Client.findOne({
        where: {
          state: query.state
        }
      }).then(function(client) {
        return github_request_token(app_config.client_id, app_config.client_secret, query.code, function(token_body) {
          var token_obj;
          token_obj = querystring.parse(token_body);
          return client.update({
            access_token: token_obj.access_token
          }).then(function() {
            return res.end('registered for repo: ' + client.repo);
          });
        });
      });
    } else if (pathname === '/api/listenpr') {
      if (method === 'get') {
        return listen_pullrequest[method](res, query, req.body);
      } else {
        req_body = '';
        req.on('data', function(ch) {
          return req_body += ch;
        });
        return req.on('end', function() {
          return listen_pullrequest[method](res, query, req_body);
        });
      }
    } else if (pathname === '/test/pull_request') {
      for (i = 0, len = clients.length; i < len; i++) {
        client = clients[i];
        if (client.repo === query.repo) {
          matched_client = client;
        }
      }
      console.log(matched_client);
      return res.end(matched_client);
    } else if (pathname === '/test/see_all_client') {
      return Client.findAll({}).then((function(clients) {
        var cl, j, len1, resbody;
        resbody = '';
        for (j = 0, len1 = clients.length; j < len1; j++) {
          cl = clients[j];
          resbody += 'cl.repo: ' + cl.repo + ',cl.body: ' + cl.body + ',cl.access_token: ' + cl.access_token + '\n';
        }
        return res.end(resbody);
      }));
    } else if (pathname === '/test/reset') {
      return Client.destroy({
        where: {},
        force: true
      }).then(function() {
        return res.end('deleted all records');
      });
    } else {
      return handler(req, res, function(err) {
        res.statusCode = 404;
        return res.end('no such location');
      });
    }
  });

  server.listen(port);

  console.log('server is listening');

}).call(this);
